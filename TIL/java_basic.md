# 1. 변수

```java
데이터타입 변수명 = 리터럴
```



> 기본형 : value들을 저장할 수 있는 타입 
>
> - 문자 - char
>
> - 숫자 - 정수 : byte, short, int ,long
>
>   ​		 - 실수 : float, double
>
> - boolean
>
> 참조형 : 주소를 저장하는 타입
>
> - API에 포함된 클래스를 메모리에 올릴 때
>
> - 내가만든 클래스
>
> - 배열

```java
class 클래스명(책){
    //데이터
    책이름;
    저자;
    출판사;
    
    //메소드
    책정보출력하기()
    {
     	db접근;
        조회;
        출력;
    }
}
```

| stack                                             | heap                                                         |
| ------------------------------------------------- | ------------------------------------------------------------ |
| 인터프리터에서 한줄 한줄 실행하면서 필요한 공간들 | new 이후에 선언되는 내용들<br />ex) String str = new String;<br /> -> 객체, 인스턴스 |

- 기본형 변수는 데이터를 stack에 저장해 사용한다.
- 참조형 변수는 heap에 객체를 올리고 주소를 이용해 참조하며 사용한다.

# 2. 기본형 리터럴

# 3. 연산자

# 4. 제어구문

> - 순차형
>
> - 선택형
>
>   - 조건문 - if
>
>     ```java
>     if(조건문 -> true or false)
>     {
>         조건이 만족할 때 실행할 명령문;
>     }
>     else
>     {
>      	조건문이 false일 때 실행할 명령문;   
>     }
>     ```
>
>   제어구문은 중첩해서 사용할 일이 많으므로 반드시 들여쓰기를 잘 맞춰서 사용한다.
>
>   Ctrl+Shift+F를 사용해서 자동으로 정렬할 수 있다.
>
>   - switch - switch
>
>   if문은 조건식의 결과가 true, false 두 가지 밖에 없기 때문에 경우의 수가 많아질수록 복잡해지고 처리시간이 오래걸린다.
>
>   ```java
>   switch(score/10)
>   			{
>   			case 10:
>   			case 9:
>   				System.out.println("A"); break;
>   			case 8:
>   				System.out.println("B"); break;
>   			case 7:
>   				System.out.println("C"); break;
>   			case 6:
>   				System.out.println("D"); break;
>   			default:
>   				System.out.println("F"); break;
>   			}
>   ```
>
>   특정 상황에서 훨씬 쉽게 표현할 수 있다는 것을 간단한 예제로 확인 할 수 있다.
>
> - 순환형
>
>   - for문
>
>     횟수가 정해져있을 때
>
>     ```java
>     for(int i=0; i<5; i++) // (초기값;조건;증감식)
>     {
>         //반복해서 실행할 명령문
>     }
>     ```
>
>     초기값 -> 조건 -> 명령문 -> 증감식 -> 조건 -> 명령문 -> 증감식 -> 조건 -> 명령문 -> 증감식 -> 조건
>
>   - 다중for문 
>
>     ```java
>     for(int i = 0; i<5; i++)
>     {
>         for(int j = 0; j<5; j++)
>         {
>             //명령문
>         }
>     }
>     ```
>
>     (i,j)형태로 움직인다고 보면 된다.
>
>   - while문
>
>     조건으로 반복문을 실행시켜야 할 때
>
>     ```java
>     while(조건문)
>     {
>         명령문;
>         if(조건문)
>         break;
>     }
>     ```
>
>     조건문에 true를 넣어 무한루프를 사용할 수 있다. 이 때 break를 활용하여 빠져나올 수 있다.
>
>   - do~while문
>
>     ```java
>     do
>     {
>         명령문;
>     }
>     while(조건문);
>     ```
>
>     do~while문은 do블럭안에 있는 명령문을 실행한 뒤에 조건을 체크한다. 무조건 1회는 실행해야 할 때 사용할 수 있다.
>
>   - break, continue
>
>     ```java
>     for()
>     {
>      	for()
>         {
>             break;
>         }
>     }
>     // 내부의 for문만 빠져나간다. = 전체 for문을 빠져나가는 것이 아니다.
>     ```
>
>     

# 5. 배열

> #### 1. 배열의 선언
>
> #### 2. 배열의 생성
>
> #### 3. 배열의 초기화

> ```java 
> int[] myarr;
> int myarr[];
> // 문법적으로 둘다 사용 가능하지만 int[]로 사용하는 것이 더 맞는 것 같다.
> 
> myarr= new int[5]; // 5칸의 int공간 생성
> 
> int[] myarr2 = new int[3];
> 
> // 기본형 변수 초기값
> // 정수형 - 0
> // boolean - false
> // 실수형 - 0.0
> ```
>
> * 배열은 참조형 변수이다. 
>
>   > myarr이라는 참조변수가 stack에 생성된다.
>   >
>   > heap에 int변수가 5칸 할당된다. myarr은 heap의 주소를 가리킨다.
>   
> * 참조형 배열만들기
>
>   ```java
>   String[] strArr = new String[3];
>   Random[] randArr = new Random[5];
>   Scanner[] keyArr = new Scanner[100];
>   		
>   System.out.println(strArr[0]);
>   System.out.println(randArr[0]);
>   System.out.println(keyArr[0]);
>   // 출력값은 모두 null이다.
>   
>   String[] arr = new String[3];
>   arr[0] = new String("java");
>   arr[1] = new String("JDBC");
>   arr[2] = new String("HTML5");
>   // arr은 stack에서 heap의 배열을 가르킨다.
>   // 각각의 공간은 heap의 다른 string 객체를 가르킨다.
>   ```
>
> * for문을 이용한 배열의 활용
>
>   ```java
>   int[] myarr = new int[50];
>   for(int i=0; i<myarr.length; i++)
>   {
>   	System.out.println(myarr[i]);
>   }
>   ```
>
>   String에서 .length()와 배열에서 .length는 다르다.

`* 배열은 메모리를 절약하는 것이 아니라 효율적으로 접근하기 위해 사용하는 것이다.`

`* 배열은 한번 만들면 길이를 바꿀 수 없다.`

​	`-> 더 큰 배열을 생성해서 복사한다 : 비효율`



# 6. Class

- 세상은 사물(object)로 이루어져 있다. 
- 객체지향언어는 사물의 속성과 기능을 분석해서 데이터와 함수로 정의함으로써 세상을 컴퓨터 속에 옮겨놓는 것처럼 가상의 세계를 구현한다.

> 코드의 재사용성이 높다.
>
> ​	-> 간단하게 객체생성과 메소드를 재사용할 수 있다.
>
> 코드의 관리가 용이하다.
>
> ​	-> 반복되는 코드를 모두 수정할 필요 없이 클래스 내부만 수정하는 것이 가능하다.
>
> 신뢰성이 높은 프로그래밍을 가능하게 한다.
>
>  	-> 제어자(prvate, public등 )를 활용해서 데이터를 보호하고, 반복내용을 줄임으로서 오류를 줄일 수 있다.

## 1. 캡슐화(encapsulation)

- 제어자를 이용해서 데이터를 은닉한다.

- 데이터에 접근할 때 메소드를 이용해서 접근하도록 하는 것이 좋다.  <u>**(Setter, Getter)**</u>

  > `+`	 public  : 아무데서나 접근할 수 있다. / 데이터에 public이 오는 경우는 없다고 보면 된다.
  > 		default : 같은 패키지에서만 접근가능
  > `#`	 protected : 같은 패키지에서만 접근가능하나 상속관계에 있다면 접근가능
  > `-` 	private : 같은 클래스 안에서만 접근 가능
  
## 2. 오버로딩

- 매개변수의 개수, 타입을 구별하여 여러 기능을 사용할 수 있도록 하는 것

  > 1.  메소드 이름이 같아야 한다.
  > 2.  매개변수의 개수 또는 타입이 달라야 한다.
  > 3.  <u>반환타입은 오버로딩 구현에 영향이 없다.</u>

- 가변인자

```java
String println(String s1){}
String println(String s1, String s2){}
String println(String s1, String s2, String s3){}
//처럼 할 필요없이
String println(String... str){}
//처럼 할 수 있다.
```

하지만 오류가 발생하기 쉽기 때문에 가능하면 사용하지 않는 것이 좋다.



## 3. 생성자(constructor)

> - 생성자 메소드명은 클래스명과 대소문자까지 정확하게 동일한 이름으로 정의해야 한다.
>
> - new 뒤에만 올 수 있다.
>
> - 객체가 생성될 때 한번만 호출되는 <u>메소드</u>
>
> - 자원을 사용하기 위해서 초기화하거나 자원관련 작업을 하거나 객체가 가지고 있는 멤버변수를 초기화 하기 위해서 사용한다.
>   
>   -> (자원 : DBMS, 네트워크, 파일시스템)
>   
> - 생성자도 오버로딩이 가능하다.
>
>   -> 주로 객체에 정의된 멤버변수의 값을 초기화 하는 작업
>
> - 처리되는 일이 없다고 하더라도 무조건 기본 생성자는 정의해야 한다.

### 3-1. 기본 생성자(default constructor)

> - 매개변수가 없는 생성자
>
> - 생성자를 하나도 정의하지 않는다면 컴파일러가 자동으로 기본생성자를 제공한다.
>
>   ​	-> 개발자가 생성자를 정의한다면 자동으로 제공하지 않는다.
>

### 3-2. 매개변수가 있는 생성자

> - 생성자를 호출함과 동시에 매개변수를 이용할 수 있다.
> - 코드를 더 직관적이고 간결하게 작성할 수 있다.

### 3-3. 생성자에서 다른 생성자 호출하기

> - 클래스이름대신 this를 사용한다.
> - 반드시 첫줄에서 호출해야한다.



## 4. static변수

static method

> - final 
>
>   변수는 상수처럼 사용
>
>   메소드는 더이상 오버라이딩 할 수 없다.
>
>   클래스는 더이상 상속할 수 없다.

## 5. 상속(inheritance)

> - 상속이란 기존의 클래스를 재사용해서 새로운 클래스를 작성하는 것
>
> - 보다 적은 양의 코드로 새로운 코드를 작성할 수 있고, 코드를 공통으로 관리할 수 있다는 장점이 있다.
>
> - 아래와 같은 형태로 작성한다.
>
>   ```java
>   class Parent{
>       
>   }
>   class Child extends Parent{
>       
>   }
>   ```
>
> - *도식화* : 일반화
>
> - 



## 6. 다형성

> - 상속
>
> - 오버라이딩
>
> - 객체의 형변환
>   - 가능한 것만
>   - 상위클래스 = new 하위클래스
>   - 하위클래스 = (하위)상위클래스 (new 하위클래스)인것만
>
> - 추상클래스

다형성이란 '여러가지 형태를 가질 수 있는 능력' 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함



> - 인터페이스
>
>   - 상속은 단순히 상위클래스의 기능을 가져오기 위해 사용하는 것이 아니다.
>
>   - <u>추상메소드, 상수만 모아놓을 특별한 클래스</u>
>
>     => public static final int , public abstract
>
>     => 요즘에는 생략해서 쓸 수 있다.
>
>   - JAVA에서는 기본적으로 다중상속이 안되는데 interface를 사용하여 할 수 있다.
>
>   - 다형성을 위해서 type으로 사용하기 위해 하는 것.























































> 
>
> 